# Relasi antar Tabel

Terdapat dua relationship yang ada pada graphql antara lain yaitu :

* object relationships (one-to-one)
* array relationships (one-to-many)


## Praktek

Kali ini, saya akan mengimplementasikan relasi tabel yang sebelumnya saya sudah pelajari dalam materi berikut pada kasus toko online: [relasi tabel](https://github.com/ferdyansahalfariz/belajar-SQL/blob/main/1.%20Membuat%20Relasi%20Tabel.md).

Adapun didalamnya terdapat 9 tabel yang membentuk sejumlah relasi baik itu one to many maupun many to one. Pada implementasi di graphql via hasura, langkah pertama yang diperlukan yaitu membuat tabel dengan field yang sesuai dengan studi kasus toko online tersebut. Pertama masuk pada bagian Data, pilih database dan skema yang digunakan (pada kasus ini digunakan database postgres dan skema public), lalu add tabel dan isi kolom yang diminta berikut:

![image](https://github.com/ferdyansahalfariz/belajar-hasura/assets/96871156/187e6cdf-2440-4db7-89b9-9f92f9164d70)

termasuk pada bagian constrain yang mana akan di cek valuenya sebelum data dimasukan ke kolom tersebut, disini saya menerapkannya pada kolom `email` di tabel `users` yang mana diharusnya memasukan format email yang benar sebelum insert valuenya. 

![image](https://github.com/ferdyansahalfariz/belajar-hasura/assets/96871156/d20d777e-b879-4f20-9894-f0e24a89a8a1)

### Foreign Key

Pada saat add table, tidak lupa juga mencantumkan foreign key sebagai referensi yang digunakan dari primary key di tabel asal ke kolom yang dihubungkan menjadi foreign key agar relasi tabel dapat terjadi dan data yang masuk konsisten. Berikut adalah contoh pengisiannya:

![image](https://github.com/ferdyansahalfariz/belajar-hasura/assets/96871156/d29a3ab8-b291-4b99-a44a-5f07bf1e45aa)

### Relationship

Setelah membentuk semua table yang diinginkan, relasi antar table belum langsung terbuat, untuk membuatnya, masuk ke menu relationship pada tabel yang diinginkan. Disana akan diberikan saran relationship hasil dari pembuatan foreign key sebelumnya yang mana dapat langsung di track relationshipnya dengan memberinya nama relationshipnya, lalu klik track relationship. Lakukan pada setiap tabel untuk membuat relasi antar tabel secara keseluruhan, selain itu relationship juga dapat dibuat secara manual terlepas dari saran yang diberikan dari hasuranya sendiri pada bagian `add relationship`. Berikut adalah contoh suggest relationship yang disarankan:

![image](https://github.com/ferdyansahalfariz/belajar-hasura/assets/96871156/118b610b-1d42-4ae4-80a0-10fa20bfcab6)

Dan berikut adalah contoh hasil pada bagian relationship setelah dibentuk relasi pada tabel yang terhubung:

![image](https://github.com/ferdyansahalfariz/belajar-hasura/assets/96871156/a1cf8498-c6c8-49d6-a741-635d307ebae5)

## Menulis dan menjalankan Query dengan relationship
Untuk melakukan ini, berdasarkan sumber [ini](https://hasura.io/docs/latest/queries/quickstart/#step-4-write-and-execute-a-query-with-a-relationship), dijelaskan untuk menjalankan query pada 1 atau lebih dari 2 tabel yang memiliki reationship, dapat langsung dipanggil nama relationshipnya dan field yang diinginkan, pada contoh ini saya memberikan nama setiap relationship yang dibuat sama dengan nama tabel yang berhubungan dengan tujuan untuk memudahkan pemanggilannya. 

Sebagai contoh, saya akan mencoba untuk GET isi tabel `languages` yang berelasi dengan tabel `users` melalui relationship dengan nama `users`. Tujuan dari query ini adalah untuk melihat setiap row dari tabel `languages` dan user mana saja yang menggunakan bahasa tersebut. Berikut adalah contoh querynya:

```
get languages and users
query MyQuery {
  languages {
    id
    language_name
    users {
      id
      username
    }
  }
}
```

Dan berikut adalah outputnya setelah di run:

```
{
  "data": {
    "languages": [
      {
        "id": 1,
        "language_name": "indonesian",
        "users": [
          {
            "id": "0b24d397-d578-4bb9-a0b7-92c395c07f15",
            "username": "ferdy"
          },
          {
            "id": "222fac0b-042a-402e-9692-1da069e2a4c1",
            "username": "satria"
          }
        ]
      },
      {
        "id": 2,
        "language_name": "English",
        "users": [
          {
            "id": "f3368a5d-22e5-46f7-8e72-14afb7e230b0",
            "username": "niko"
          },
          {
            "id": "ac4ed3b3-9860-4e0d-88c4-3e3d9ed3655d",
            "username": "edo"
          }
        ]
      }
    ]
  }
}
```

Disana diberikan hasil bahwa bahasa indonesia dengan id 1 digunakan atau dalam kata lain dihubungkan oleh sejumlah user yaitu ferdy dan satria sementara bahasa inggris dengan id 2 digunakan oleh user niko dan edo.

Sebagai contoh yang lebih kompleks di mana akan digunakan query yang memanggil tabel `users`, `languages`, `orders`, `order_items`, dan `products` untuk memberikan hasil dari order apa saya yang sudah dilakukan oleh satu user tertentu dan diberikan datanya secara detail sampai ke nama produk yang diorder. Berikut adalah contoh querynya:

```
query CheckOrderByUserId($id: uuid!) {
  users_by_pk(id: $id) {
    id
    username
    email
    password
    updated_at
    created_at
    languages {
      id
      language_name
    }
    orders {
      id
      order_time
      status
      total_amount
      order_items {
        price
        quantity
        products {
          name
        }
      }
    }
  }
}
```

query CheckOrderByUserId menggunakan query variable berikut untuk input user_id nya:

```
{
  "id": "0b24d397-d578-4bb9-a0b7-92c395c07f15"
}
```

Dan berikut adalah contoh outputnya setelah di run:

```
{
  "data": {
    "users_by_pk": {
      "id": "0b24d397-d578-4bb9-a0b7-92c395c07f15",
      "username": "ferdy",
      "email": "ferdy@gmail.com",
      "password": "ferdy",
      "updated_at": "2024-07-05T03:33:29.359927+00:00",
      "created_at": "2024-07-05T03:33:29.359927+00:00",
      "languages": {
        "id": 1,
        "language_name": "indonesian"
      },
      "orders": [
        {
          "id": "09658d46-4117-476c-86f0-d08dbb385ab6",
          "order_time": "2024-07-05T07:27:16.821841+00:00",
          "status": "processed",
          "total_amount": 1000000,
          "order_items": [
            {
              "price": 1000000,
              "quantity": 1,
              "products": {
                "name": "Asus Mouse Gaming"
              }
            }
          ]
        }
      ]
    }
  }
}
```

## Subscription

Selain mutation yang berguna untuk merubah isi data dalam database, dalam graphql hasura terdapat subscription yang bekerja mirip seperti consumer pada kafka yang selalu menerima setiap input yang masuk dari producer ke topic selama servicenya terus berjalan, subscription paa graphql juga akan terus running untuk menerima update dari database. 

Sumber: [Subscription](https://hasura.io/docs/latest/subscriptions/overview/)

berikut adalah contoh query untuk subscription:

```
subscription MySubscription {
  products {
    id
    name
    description
    price
    categories {
      name
    }
    created_at
  }
}
```

Jika dijalankan, maka query tersebut akan subscribe ke tabel product untuk terus menerima update jika ada penambahan ataupun pengurangan isi row dalam tabel product.

Sebagai contoh, jika dijalankan akan menghasilkan output berikut yang menampilkan 1 data pada tabel `products` dengan nama `Asus Mouse Gaming`:

![image](https://github.com/ferdyansahalfariz/belajar-hasura/assets/96871156/75ac394a-dee4-4860-81e8-f5a0203dcdd5)

Kemudian tanpa menghentikan subscriptionnya, tambahkan row baru pada tabel `products`, jika sudah maka output dari subscription akan otomatis terupdate menjadi seperti berikut:

![image](https://github.com/ferdyansahalfariz/belajar-hasura/assets/96871156/2245a355-d888-42bb-b0b4-cc661ced4b54)

hal ini juga berlaku saat data dalam tabel di delete ataupun dilakukan update.

# Data Transformasi

## Extend schema dengan View

ref : https://hasura.io/docs/latest/schema/postgres/views/

Dalam proses transformasi data, di postgres terdapat sebuah fitur [`View`](https://hasura.io/learn/database/postgresql/views/). [View](https://hasura.io/docs/latest/schema/postgres/views/) merupakan sebuah query bernama yang kompleks dan digunakan berulang kali baik untuk menampilkan sejumlah data kolom pilihan dari tabel ataupun join tabel. Jadi saya akan mencoba membuat view di hasura dengan kasus dimana saya ingin menampilkan siapa saja user yang `last_seen` nya berada di 30 detik terakhir dengan menggunakan View.

Sebelumnya pastikan terdapat tabel `users` dengan berisi kolom `last_seen`. kemudian masuk ke bagian `data` -> `SQL` lalu jalankan query berikut:

```
CREATE OR REPLACE VIEW "public"."online_users" AS
 SELECT users.id,
    users.last_seen
   FROM users
  WHERE (users.last_seen >= (now() - '00:00:30'::interval));
```

Klik `run` untuk membuatnya

![image](https://github.com/user-attachments/assets/dfc31ab5-d7e0-43b8-849b-ec2f9566de6f)

Setelah itu akan muncul skema `online_users` yang mana dapat dijalankan querynya untuk mendapatkan data user yang online 30 detik terakhir. Namun sebelum itu, view juga dapat direlasikan ke tabel, dalam hal ini saya terlebih dahulu membuat relasi antara `online_users` dengan tabel `users` dengan masuk ke `Data` -> `online_users` -> `Relationships`. Buat relasi dengan menghubungkan kolom `id` di view `online_users` dengan kolom `id` di tabel `users`, simpan.

![image](https://github.com/user-attachments/assets/ecfe1ee6-b42b-4831-be87-f05b73afbc4a)

Update salah satu row di tabel `users` pada kolom `last_seen` menjadi `now()` dan jalankan query sebelum lewat 30 detik.

Query dapat dijalankan pada halaman API dengan run contoh query berikut:

```
query {
  online_users {
    id
    last_seen
    user {
      id
      name
    }
  }
}
```

Berikut adalah hasilnya

![image](https://github.com/user-attachments/assets/c831b986-ad4e-4baf-8c93-1a8b1a98b31c)

### Studi kasus kedua

Selanjutnya saya ingin mencoba membuat view untuk melihat rata rata dari rating sejumlah produk yang dimiliki oleh suatu merchant. tabel `merchants` memiliki relationship array dengan tabel `products` dengan isi berikut:

![image](https://github.com/user-attachments/assets/8302bf5e-a22b-4c25-9c0f-96f014aa7274)

Kemudian buat view pada halaman data-> SQL lalu masukan query berikut:

```
CREATE OR REPLACE VIEW "public"."merchant_average_rating" AS
  SELECT products.id_merchant, avg(rating)
    FROM products
    GROUP BY id_merchant;
```

Buat juga relationship antara view `merchant_average_rating` dengan tabel `merchants`.

Berikut adalah data di tabel Products
![image](https://github.com/user-attachments/assets/67521c50-86ed-4618-b820-4abc57190380)

Jalankan query dengan contoh berikut yang menunjukan rata rata rating yang dimiliki suatu merchant berdasarkan rating produk yang berelasi dengannya

```
query MyQuery {
  merchant_average_rating {
    merchants {
      id
      nama
    }
    avg
  }
}
```

![image](https://github.com/user-attachments/assets/c560bad9-61e1-4277-a7bd-a6f6f2266c6b)

## Extend schema dengan SQL function dan computed fields

Disini saya akan mempraktekan pengembangan skema lebih lanjut diluar dari skema default yang sudah di generate di hasura menggunakan [custom function](https://hasura.io/docs/latest/schema/postgres/custom-functions/) dan juga [computed field](https://hasura.io/docs/latest/schema/postgres/computed-fields/).

Postgres user-defined SQL function dapat digunakan untuk membungkus suatu custom bisnis logic ataupun untuk extend function dan operasi yang dibuat SQL.

Hasura mengizinkan untuk meng-query custom function baik dengan query ataupun subscription ataupun untuk VOLATILE function sebagai mutation. ini lah yang disebut custom function.

Sementara untuk computed field merupakan value ataupun objek virtual yang di komputasi secara dinamik dan dapat di query bersama dengan kolom tabel atau view lainnya.

Computed field di komputasi berdasarkan request dan bekerja dengan mengeksekusi user-defined SQL function atau diketahui juga sebagai stored procedure yang akan mengambil kolom dari tabel atau view dan nilai custom lain jika dibutuhkan sebagai input untuk mengkomputasi field nya.

### Studi Kasus
Disini saya memiliki 2 tabel yaitu `authors` dan `article` yang masing masingnya memiliki kolom berikut:

![image](https://github.com/user-attachments/assets/a26f6b1a-8366-47a2-96ea-97673b07b4bb)

![image](https://github.com/user-attachments/assets/240d7c7e-d893-42c6-b657-74db0f09599d)

keduanya berelasi dengan hubungan one to many melalui FK `author_id` yang mana untuk tiap row di `authors` dapat berelasi dengan lebih dari 1 row `article`.

Dalam **computed field** terdapat 2 jenis yaitu scalar type yang mengasosiasikan function sql yang mengembalikan nilai `base type` seperti integer, text, boolean dan lain sebagainya. sementara yang kedua yaitu table computed field yang me return `SETOF <table-name>` atau nilai dari suatu tabel. Tabel yang di return juga harus sudah di define atau sudah di track hasura sebelumnya untuk bisa membuat computed field tipe ini.

Saya akan memulainya dari scalar computed field yang mana akan membuat function yang menggabungkan 2 kolom `first_name` serta `lat_name` menjadi sebuah computed field bernama `full_name`, proses dimulai dengan run query berikut ke bagian data-> SQL dan run query ini:

```
CREATE FUNCTION author_full_name(author_row authors)
RETURNS TEXT AS $$
  SELECT author_row.first_name || ' ' || author_row.last_name
$$ LANGUAGE sql STABLE;
```

Setelah itu tambahkan function `author_full_name` ke computed field dengan cara masuk ke tabel `authors` lalu masuk ke bagian `modify` dan click `add` pada bagian `computed field`. Masukan nama, dan pilih functionnya lalu simpan

![image](https://github.com/user-attachments/assets/b0734597-2643-4e59-a850-049cfdd21256)

Jalankan query berikut untuk melihat hasilnya:

```
query {
  authors {
    id
    first_name
    last_name
    full_name
  }
}
```

terlihat computed field `full_name` berhasil ditampilkan

![image](https://github.com/user-attachments/assets/1c8e9527-e983-49fc-9571-e938278f559e)

Selanjutnya saya akan mencoba membuat computed field bertipe tabel dengan diawali membuat function berikut:

```
CREATE FUNCTION filter_author_article(author_row authors, search text)
RETURNS SETOF article AS $$
  SELECT *
  FROM article
  WHERE
    ( title ilike ('%' || search || '%')
      OR content ilike ('%' || search || '%')
    ) AND author_id = author_row.id
$$ LANGUAGE sql STABLE;
```
Function tersebut digunakan untuk melakukan searching dari kata kunci `search` yang dimasukan untuk dicocokan ke kolom `title` ataupun `content`. Setelah function dibuat, tambahkan juga di tabel `authors` untuk computed fieldnya.

![image](https://github.com/user-attachments/assets/5d4d55fa-9b72-4260-ac51-28f761872681)

simpan dan test dengan query berikut yang saya praktekan dengan menginput value `search` dengan isi `first`, lalu outputnya akan menampilkan setiap row dari article yang memiliki value `first` pada kolom `title` ataupun pada kolom `content` nya.

![image](https://github.com/user-attachments/assets/df3195ef-fc3d-417a-8ba4-fcb4534e38aa)

#### kombinasi view dan custom function

Selain itu, saya juga mencoba untuk membuat sebuah view berdasarkan custom function yang sudah dibuat sebelumnya, berikut adalah query untuk create view nya:

```
CREATE
OR REPLACE VIEW "public"."author_public" AS
SELECT
  authors.id,
  author_full_name(authors.*) AS name,
  authors.city
FROM
  authors;
```

view yang dibuat berguna untuk menampilkan sejumlah data yang dapat diakses secara public seperti `name` dan `city` saja tanpa perlu menampilkan seluruh datanya seperti `phone` dan `address` nya.

query tersebut akan membuat sebuah view dari potongan sejumlah kolom di tabel `authors` dibarengi dengan penggunaan function `author_full_name` yang bekerja dengan menggabungkan kolom `first_name` dan `last_name` dari tabel `authors`.

![image](https://github.com/user-attachments/assets/a77c0178-59fc-493c-9149-b81653162485)

berikut adalah hasilnya setelah di run

![image](https://github.com/user-attachments/assets/e49e894d-a572-440b-98e1-96a301c94757)


# Relasi antar database

Disini saya mencoba membuat relationship antar database yang mana terdapat 2 database dengan nama `default` serta `testsejuta`. saya mencoba menghubungkan tabel `carts` yang ada di database `default` dengan tabel `users` dan tabel `products` yang ada di database `testsejuta` berikut pengaturan relationshipnya.

![image](https://github.com/user-attachments/assets/d6c38588-aa08-45fd-ad6b-4df083789ea7)

![image](https://github.com/user-attachments/assets/c23c1d7f-b7f2-44f3-91e4-92116d05036b)

Saya akan mencoba insert tabel `carts` di database `default` dengan berdasarkan data di tabel `users` dan `products` yang ada di database `testsejuta`

```
mutation MyMutation {
  insert_carts_one(object: {product_id: "3", user_id: "7cf0a66c-65b7-11ed-b904-fb49f034fbbb"}) {
    id
    users {
      name
    }
    products {
      nama
      deskripsi
      harga
    }
  }
}
```

![image](https://github.com/user-attachments/assets/7b09cf7d-741d-45e4-a897-8663b2e64539)

# Relasi antar database ke remote skema

Disini saya membuat tabel `khs` di database `default`, lalu saya menggunakan remote skema dari HGE yang saya instance di cloud berikut:

![image](https://github.com/user-attachments/assets/2cd6a6ce-b263-460e-b4eb-0915109bbd11)

saya kemudian akan menghubungkan `khs` dengan skema `mahasiswa` dan `kelas` yang mana berada di remote schema. berikut cara menghubungkan relationshipnya:

![image](https://github.com/user-attachments/assets/8c097612-ac22-44c9-ad6e-7950dbce8d05)

dibuat agar kolom `id_mahasiswa` pada tabel `khs` di database `default`, equal dengan `id` pada skema `mahasiswa` di remote skema.


Insert
```
mutation MyMutation {
  insert_khs_one(object: {id_kelas: "6b223a93-65b5-4bbf-bad1-2390e682cb6e", tahun_ajaran: "ganjil 2024", id_mahasiswa: "7909729c-5e83-4a54-a878-a50de207fd83"}) {
    id
    mahasiswa {
      nama
    }
    kelas {
      mata_kuliah
      sks
    }
    tahun_ajaran
  }
}

```

![image](https://github.com/user-attachments/assets/7237abcb-19f8-4e19-a31b-a854ba5575b1)

get

```
query MyQuery {
  khs {
    id
    tahun_ajaran
    kelas {
      id
      mata_kuliah
      pertemuan
      sks
    }
    mahasiswa {
      id
      nama
      nim
      alamat
    }
  }
}
```

![image](https://github.com/user-attachments/assets/013f23e7-ea92-4d05-bf9c-62a9fdab29cf)



